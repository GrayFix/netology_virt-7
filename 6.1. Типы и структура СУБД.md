# 6.1. Типы и структура СУБД

1. Предложения по использованию БД:
-  Электронные чеки в json виде - с одной стороны думаю хорошо подойдет MongoDB, но с другой стороны чек имет четко описанную структуру и хорошо ложиться и модель реляционной БД. А актуальные верси БД MS SQL, MySql, PostgreSQL уже умеют достаточно хорошо работать с JSON.
-  Для пунктов "Склады и автомобильные дороги для логистической компании" и "Генеалогические деревья" я бы предложил сильно не выдумывать и использовать обычную реляционную базу данных. Наприме MySql или PostgreSQL.
-  Для пунктов "Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации" и "Отношения клиент-покупка для интернет-магазина" очень хорошо подходят in-memory БД формата ключ-значение, например Redis.

2. Классификация согласно CAP-теореме:
-  Данные записываются на все узлы с задержкой до часа (асинхронная запись) - тут описан принцип доступности (Availability), также не соблюдается принцип согласованности (Consistency). По поводу Partition Tolerance ничего сказать по описанию нельзя.
-  При сетевых сбоях, система может разделиться на 2 раздельных кластера - тут описан механизм устойчивости к разделению сети (Partition Tolerance). По поводу Availability или Consistency ничего не сказано.
-  Система может не прислать корректный ответ или сбросить соединение - описано нарушение принципа Availability и Consistency. По Partition Tolerance ничего не сказано. 

2a. Классификация согласно PACELC-теореме:
-  Данные записываются на все узлы с задержкой до часа (асинхронная запись) - думаю больше подойдет ребро PA/EL. Т.к согласно теореме выбор идет между консистентностью и доступностью/latency. Тут выбор получается сделан с расчетом на доступность/latency в ущерб консистентности.
-  При сетевых сбоях, система может разделиться на 2 раздельных кластера - тут подходят ребра PA/EC или PA/EL, т.к. не понятно на что идет основной расчет.
-  Система может не прислать корректный ответ или сбросить соединение - это может быть точой EL, т.к система не обладает ни консистентностью и доступностью. Остается только Latency.

3. BASE и ACID приципы не могут сочетаться в одной системе по опредлеению. Но могут сущестовать гибридные решения, где они сочетаюся частично.  
4. Система с "фиксация некоторых значений с временем жизни" и "реакция на истечение таймаута" - в первую очередь не понятно какая реакция. Если какая-то произвольная то таких готовых БД я не нашел. Можно обойись заданием по расписанию которое будет мониторить истекшие записи и что-то делать. Такое можно реализовать на любой БД. В некоторых NoSQL БД типа MongoDB, Redis, Memcached есть механизмы для установи TTL на элемент БД (документ или пару ключ:значения), после истечения TTL элемент БД обычно удаляется. Также Redis может через keyspace notifications публиковать уведомление в очередь Pub/Sub. 

4a. Key-value хранилище, которое имеет механизм Pub/Sub явный намек на Redis. Думаю основная проблема что это в первую очередь Key-value хранилище и для нагруженной системы MQ все таки пригодно не так сильно как специфические MQ типа RabbitMQ или Kafka которые стали практичеси стандартом с момента написания предлагаемой к прочтению статьи. И в плане распределения нагрузки по серверам и в плане отказоустойчивости. 
